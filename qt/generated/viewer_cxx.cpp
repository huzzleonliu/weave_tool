/* generated by rust_qt_binding_generator */
#include "viewer_cxx.h"

namespace {

    typedef void (*qstring_set)(QString* val, const char* utf8, int nbytes);
    void set_qstring(QString* val, const char* utf8, int nbytes) {
        *val = QString::fromUtf8(utf8, nbytes);
    }
    inline void imageViewerDisplay_pathChanged(ImageViewer* o)
    {
        Q_EMIT o->display_pathChanged();
    }
    inline void imageViewerHas_pendingChanged(ImageViewer* o)
    {
        Q_EMIT o->has_pendingChanged();
    }
    inline void imageViewerImage_pathChanged(ImageViewer* o)
    {
        Q_EMIT o->image_pathChanged();
    }
}
extern "C" {
    ImageViewer::Private* image_viewer_new(ImageViewer*, void (*)(ImageViewer*), void (*)(ImageViewer*), void (*)(ImageViewer*));
    void image_viewer_free(ImageViewer::Private*);
    void image_viewer_display_path_get(const ImageViewer::Private*, QString*, qstring_set);
    bool image_viewer_has_pending_get(const ImageViewer::Private*);
    void image_viewer_image_path_get(const ImageViewer::Private*, QString*, qstring_set);
    void image_viewer_apply_threshold_mapping(const ImageViewer::Private*, const ushort*, int);
    void image_viewer_cleanup_scattered_pixels(const ImageViewer::Private*);
    void image_viewer_cleanup_temp_files(const ImageViewer::Private*);
    void image_viewer_gray_preview(const ImageViewer::Private*);
    void image_viewer_refresh_display(const ImageViewer::Private*);
    void image_viewer_save_processed(const ImageViewer::Private*);
    void image_viewer_set_image_path(const ImageViewer::Private*, const ushort*, int);
    void image_viewer_start_watcher(const ImageViewer::Private*, const ushort*, int);
};

ImageViewer::ImageViewer(bool /*owned*/, QObject *parent):
    QObject(parent),
    m_d(nullptr),
    m_ownsPrivate(false)
{
}

ImageViewer::ImageViewer(QObject *parent):
    QObject(parent),
    m_d(image_viewer_new(this,
        imageViewerDisplay_pathChanged,
        imageViewerHas_pendingChanged,
        imageViewerImage_pathChanged)),
    m_ownsPrivate(true)
{
}

ImageViewer::~ImageViewer() {
    if (m_ownsPrivate) {
        image_viewer_free(m_d);
    }
}
QString ImageViewer::display_path() const
{
    QString v;
    image_viewer_display_path_get(m_d, &v, set_qstring);
    return v;
}
bool ImageViewer::has_pending() const
{
    return image_viewer_has_pending_get(m_d);
}
QString ImageViewer::image_path() const
{
    QString v;
    image_viewer_image_path_get(m_d, &v, set_qstring);
    return v;
}
void ImageViewer::apply_threshold_mapping(const QString& thresholds_json) const
{
    return image_viewer_apply_threshold_mapping(m_d, thresholds_json.utf16(), thresholds_json.size());
}
void ImageViewer::cleanup_scattered_pixels() const
{
    return image_viewer_cleanup_scattered_pixels(m_d);
}
void ImageViewer::cleanup_temp_files() const
{
    return image_viewer_cleanup_temp_files(m_d);
}
void ImageViewer::gray_preview() const
{
    return image_viewer_gray_preview(m_d);
}
void ImageViewer::refresh_display() const
{
    return image_viewer_refresh_display(m_d);
}
void ImageViewer::save_processed() const
{
    return image_viewer_save_processed(m_d);
}
void ImageViewer::set_image_path(const QString& path) const
{
    return image_viewer_set_image_path(m_d, path.utf16(), path.size());
}
void ImageViewer::start_watcher(const QString& path) const
{
    return image_viewer_start_watcher(m_d, path.utf16(), path.size());
}
